    React utilizes the concept of Virtual DOM, as discussed in the previous article, to create an abstraction layer that generates and manages the real DOM elements on the browser. In React, each Virtual DOM element is called a "React element," which serves as the smallest building block within this abstraction layer.

A React element is essentially a plain JavaScript object that describes the structure and data of a corresponding "real DOM" node. You can create a React element using the `createElement()` method provided by React. For example:

```jsx
import React from "react";

const buttonReactElement = React.createElement(
  'button', // Element type
  { id: 'button1' }, // Properties
  'I am a button' // Child elements
);

```

**Explanation:**

The first parameter of `createElement()` is the element type, the second parameter is its properties, and the third parameter is its child elements.

When you log this React element to the console, you'll see that it's just a plain JavaScript object that looks like this:

```jsx
// buttonReactElement
{
  type: 'button',
  props: { id: 'button1', children: 'I am a button' },
  key: null,
  ref: null,
  $$typeof: Symbol('react.element'),
};

```

**Explanation:**

Indeed, it is just a simple JavaScript object. However, when this React element is processed by React, it automatically generates the corresponding real DOM elements in the browser:

!https://i.imgur.com/XWW3fSx.png

At this point, you can find the actual DOM element generated by React in the real DOM tree:

```jsx
const buttonDomElement = document.getElementById('button1');

```

**Explanation:**

In the example above:

- `buttonReactElement`
    - This is a React element. Before being rendered by React, it is just a JavaScript object, essentially a Virtual DOM element, used by developers to describe and define what the resulting real DOM should look like.
- `buttonDomElement`
    - This is the actual DOM node, generated by React based on the contents of the React element.

---

Just like real DOM, React elements can also form nested tree structures. You can specify a React element's children as another one or more React elements.

If there are multiple child elements, you can continue to fill in the fourth, fifth, sixth, and so on parameters in `createElement()`. React will treat them as subsequent child elements:

```jsx
const reactElement = React.createElement(
  'div',
  { id: 'wrapper', className: 'foo' },
  React.createElement(
    'ul',
    { id: 'list-01' },
    // From the third parameter, each parameter is a child element
    React.createElement('li', { className: 'list-item' }, 'item 1'),
    // The fourth parameter is the second child element
    React.createElement('li', { className: 'list-item' }, 'item 2'),
    // The fifth parameter is the third child element
    React.createElement('li', { className: 'list-item' }, 'item 3'),
  ),
  React.createElement(
    'button',
    { id: 'button1' },
    'I am a button'
  )
);

```

**Explanation:**

This will produce the corresponding browser DOM result:

!https://i.imgur.com/GBwWBRZ.png

As shown above, by defining the content of React elements, we can indirectly control the resulting DOM structure on the screen. There is a clear and complete correspondence between the two.

However, it's important to note that React elements are immutable once created. Why is that?

As mentioned earlier, the Virtual DOM elements in React are essentially React elements. To optimize the performance of DOM operations, when the UI needs to be updated, we need to compare the old Virtual DOM tree structure with the new version of the Virtual DOM tree to determine which parts actually need to be updated. If previously created old React elements could be modified or overwritten, there would be no reliable historical basis for comparing with the new React elements.

Therefore, React elements conceptually represent the "UI at a specific point in time." When we want to describe a new UI structure, we need to create a new set of React elements to provide to React, never modifying old React elements, to ensure the validity and maintenance of this comparison mechanism.

**Recommended resources:**

- [React Documentation: `createElement()`](https://reactjs.org/docs/react-api.html#createelement)

### **Additional Notes: Differences in Properties Between React Elements and DOM**

You might notice that some property names and formats of React elements differ slightly from their real DOM counterparts. Here are some of the most common and frequently used differences:

- All DOM properties and attributes (including event handlers) are named using camelCase.
    - For example: `onclick` becomes `onClick`, `tabindex` becomes `tabIndex`, etc.
    - `aria-*` and `data-*` attributes are exceptions and should remain in all lowercase. For example, `aria-label` stays as is.
- Some properties are renamed to avoid conflicts with JavaScript reserved keywords:
    - `class` becomes `className`
    - The `for` attribute in `<label>` becomes `htmlFor`
- The format for specifying inline styles using the `style` attribute differs:
    - In React elements, `style` is specified as an object rather than a string as in HTML tags, and CSS property names are camelCased.
    - For example:
        - In HTML: `style="font-size: 14px; color: red;"`
        - In React element: `{ style: { fontSize: '14px', color: 'red' } }`

For a detailed comparison, you can refer to the official documentation:

https://reactjs.org/docs/dom-elements.html#differences-in-attributes

### Understanding React Elements and How They Generate Real DOM Elements

After grasping the concept of React elements as the smallest building blocks in the virtual abstraction layer, let's dive into how these React elements translate into real DOM elements. While the code to achieve this is relatively straightforward, understanding each step of the process helps internalize how the "Virtual DOM" concept is practically applied in React.

### Reconciler & Renderer

React divides the task of defining and generating the UI into two main parts: the Reconciler and the Renderer.

- **Reconciler:** This part handles the construction, management, and scheduling of the abstract layer, i.e., the "Virtual DOM" concept and managing React elements. When the UI needs to update, the Reconciler creates a new Virtual DOM tree (React elements), compares it with the previous Virtual DOM tree to find the differences, and informs the Renderer. This process is known as "Reconciliation," which will be explained in detail in later sections.
    - Developers interact with the Reconciler via React's API (e.g., defining and creating React elements to decide the UI structure, using React's built-in API to control data updates, etc.), covering most front-end UI control and manipulation needs without directly handling the real DOM.
- **Renderer:** This part takes the React elements (Virtual DOM elements) created and managed by the Reconciler and generates the corresponding actual UI (real DOM elements) in the target environment (browser).
    - When the UI needs updating, the Reconciler identifies the parts of the UI that need actual updates and instructs the Renderer. The Renderer then interacts with the browser to update the necessary DOM elements, completing the UI update.
    - The React Renderer used for browser environments is called "React DOM."

### More About Different Types of React Renderers

Thanks to React separating the abstract layer management (Reconciler) and rendering the abstract layer into actual UI (Renderer) into two parts, React can generate UI beyond just the browser DOM. For example, React Native for creating native Android/iOS app UIs, React-pdf for generating PDF documents, etc.

Besides React's official `react-dom` and `react-native`, various community-maintained React Renderers are also flourishing.

In non-browser environments, the supported element types differ from the familiar DOM elements. For instance, in React Native, elements like `Text` and `View` correspond to native components of Android/iOS apps, and the specialized Renderer translates them into native UI in the apps.

### React DOM

In front-end development for browser environments, we use React's official `react-dom` as the Renderer to generate and manage the real DOM.

Conceptually, we specify a particular area of the browser's screen for React to fully control, continuously converting and syncing the Virtual DOM to the real DOM.

You first need to designate a target area as a container in your Web App's HTML body to serve as the output target for the real DOM elements generated by React. Typically, an empty `<div>` with an arbitrary `id` is used so we can reference this DOM element in JavaScript:

```html
<body>
  <div id="root-container">
    <!-- The actual DOM elements generated by React will be injected here -->
  </div>
</body>

```

### Explanation:

Next, in JavaScript, we obtain this container element and use the `ReactDOM.createRoot()` method to create a "root," which serves as the entry point for rendering and managing the resulting DOM elements:

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';  // Renderer for browser DOM environment

// Get the predefined container element in HTML as the output container for React-generated DOM elements
const rootContainerElement = document.getElementById('root-container');

// Create a rendering entry point (root) for the React App using this container element
const root = ReactDOM.createRoot(rootContainerElement);

// ....

```

### Explanation:

We can then use the `root.render()` method to convert and render a React element into an actual DOM element:

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';  // Renderer for browser DOM environment

// Get the predefined container element in HTML as the output container for React-generated DOM elements
const rootContainerElement = document.getElementById('root-container');

// Create a rendering entry point (root) for the React App using this container element
const root = ReactDOM.createRoot(rootContainerElement);

// Prepare a React element
const buttonReactElement = React.createElement(
  'button',           // Element type
  { id: 'button1' },  // Properties
  'I am a button'     // Child elements
);

// Render the React element into an actual DOM element in this root
root.render(buttonReactElement);

```

### Explanation:

This generates the result in the browser's screen, placing the corresponding DOM element (the button) inside the initially specified container element (the `div` with `id='root-container'`):

!https://i.imgur.com/XWW3fSx.png

After rendering the React element to the target container, React takes over the complete control and manipulation of all contents within this container. Thus, it is generally not recommended to manually manipulate or modify the DOM elements within React's control, as this could lead to inconsistencies between React's internal Virtual DOM tree and the actual DOM tree, causing potential issues.

React only updates the DOM elements that actually need changes. As mentioned earlier, React elements conceptually represent the "UI at a specific point in time." Hence, once a React element is created, it cannot be modified. To update the UI, you must create a new set of React elements and provide them to the Renderer:

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';

const rootContainerElement = document.getElementById('root-container');
const root = ReactDOM.createRoot(rootContainerElement);

setInterval(
  () => {
    const reactElement = (
      <div>
        <h1>Hello world</h1>
        <h2>Time is {new Date().toLocaleTimeString()}</h2>
      </div>
    );

    root.render(reactElement);
  },
  1000
);

```

### Explanation:

In this example, every second, the `setInterval` callback creates a new React element and calls `root.render()` again. The actual output looks like this:

https://codesandbox.io/s/fancy-fog-pt7um0

You can observe that each time a new React element is created and rendered, the actual DOM structure in the root container syncs with the new React element. Only the parts of the DOM that actually need changes (the text inside the `<h2>` element showing the time) are updated, while the rest remain untouched, highlighting the efficiency of the Virtual DOM in minimizing unnecessary DOM operations.

In practical development, however, we typically don't call `root.render()` multiple times like this. Instead, we call it once and use stateful components that trigger UI updates through built-in mechanisms. We'll delve deeper into how React manages UI updates using component mechanisms in later chapters.

**Recommended resources:**

- [React Documentation: `createRoot()`](https://reactjs.org/docs/react-api.html#createroot)

### Additional Notes

### What Happens if the Container Element Already Has Content?

If the container element for the root already contains content, React will overwrite it with the output generated from the React element. Since the root container is entirely managed by React, React will ensure the DOM content within the root container is always in sync with the structure defined by the React element, disregarding any pre-existing DOM content.

### Can There Be Multiple Roots?

React supports having multiple roots in a front-end app. However, for a complete SPA (Single-Page Application), it's generally recommended to use a single React root to manage the entire front-end app, providing a comprehensive UI management scope.

If your front-end app integrates React with other front-end solutions, you can create multiple roots to manage smaller sections using React, achieving more lightweight integration.

### Why Not Use `document.body` as the Root Container Element?

You might wonder why we don't use `document.body` directly as the root container element. React discourages this because third-party libraries often manipulate `document.body`'s child elements. Using it as React's root container might lead to unstable control and management of the DOM elements within it. It's better to create a separate container element within the `body` for React's root.

### Version Differences in React DOM API

In older React code or articles, you might encounter a different React DOM API. This is because `createRoot` is a new method introduced in React 18. In versions ≤ React 17, the API to call React DOM for rendering differs:

```jsx
// React version ≤ 17

// Note the import from 'react-dom', not 'react-dom/client' used in React 18
import ReactDOM from 'react-dom';

const buttonReactElement = React.createElement(
  'button',
  { id: 'button1' },
  'I am a button'
);

const targetContainerDomElement = document.getElementById('root-container');

// Directly call the render method from ReactDOM without creating a root
ReactDOM.render(buttonReactElement, targetContainerDomElement);

```

**Reference:**

- [React Documentation: Rendering Elements](https://reactjs.org/docs/rendering-elements.html)